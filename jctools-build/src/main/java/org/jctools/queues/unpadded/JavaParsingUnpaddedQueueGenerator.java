package org.jctools.queues.unpadded;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.*;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.comments.BlockComment;
import com.github.javaparser.ast.comments.Comment;
import com.github.javaparser.ast.comments.JavadocComment;
import com.github.javaparser.ast.comments.LineComment;
import com.github.javaparser.ast.expr.ClassExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import java.io.File;
import java.io.FileWriter;
public class JavaParsingUnpaddedQueueGenerator extends VoidVisitorAdapter<Void> {

    protected static final String INDENT_LEVEL = "    ";
    protected final String sourceFileName;

    public static void main(String[] args) throws Exception {
        main(JavaParsingUnpaddedQueueGenerator.class, args);
    }

    static void main(Class<? extends JavaParsingUnpaddedQueueGenerator> generatorClass, String[] args) throws Exception {

        if (args.length < 2) {
            throw new IllegalArgumentException("Usage: outputDirectory inputSourceFiles");
        }

        File outputDirectory = new File(args[0]);

        for (int i = 1; i < args.length; i++) {
            File file = new File(args[i]);
            System.out.println("Processing " + file);
            CompilationUnit cu = new JavaParser().parse(file).getResult().get();
            JavaParsingUnpaddedQueueGenerator generator = buildGenerator(generatorClass, file.getName());
            generator.visit(cu, null);
            cu.addImport(new ImportDeclaration("org.jctools.queues", false, true));
            cleanupPaddingComments(cu);

            String outputFileName = generator.translateQueueName(file.getName().replace(".java", "")) + ".java";

            try (FileWriter writer = new FileWriter(new File(outputDirectory, outputFileName))) {
                writer.write(cu.toString());
            }

            System.out.println("Saved to " + outputFileName);
        }
    }

    private static void cleanupPaddingComments(CompilationUnit cu)
    {
        for (Comment comment : cu.getAllContainedComments())
        {
            String content = comment.getContent();
            if (content.contains("byte b") || content.contains("drop 8b") || content.contains("drop 16b") ) {
                comment.remove();
            }
        }
    }

    JavaParsingUnpaddedQueueGenerator(String sourceFileName) {
        this.sourceFileName = sourceFileName;
    }

    protected String translateQueueName(String qName) {
        if (qName.contains("LinkedQueue") || qName.contains("LinkedArrayQueue")) {
            return qName.replace("Linked", "LinkedUnpadded");
        }

        if (qName.contains("ArrayQueue")) {
            return qName.replace("ArrayQueue", "UnpaddedArrayQueue");
        }

        throw new IllegalArgumentException("Unexpected queue name: " + qName);

    }

    @Override
    public void visit(PackageDeclaration n, Void arg) {
        super.visit(n, arg);
        // Change the package of the output
        n.setName("org.jctools.queues.unpadded");
    }

    @Override
    public void visit(ClassOrInterfaceDeclaration node, Void arg) {
        super.visit(node, arg);
        String nameAsString = node.getNameAsString();
        if (!nameAsString.contains("Queue"))
            return;
        // fixup inheritance
        replaceParentClasses(node);
        // fixup name
        node.setName(translateQueueName(nameAsString));

        node.setJavadocComment(formatMultilineJavadoc(0,
            "NOTE: This class was automatically generated by "
                + this.getClass().getName(),
            "which can found in the jctools-build module. The original source file is " + sourceFileName + ".")
            + node.getJavadocComment().orElse(new JavadocComment("")).getContent());

        // remove padding fields
        for (FieldDeclaration field : node.getFields())
        {
            String fieldName = field.getVariables().get(0).getNameAsString();
            if (fieldName.startsWith("b0") || fieldName.startsWith("b1")) {
                node.remove(field);
            }
        }
    }

    @Override
    public void visit(MethodCallExpr n, Void arg)
    {
        super.visit(n, arg);
        if (!n.getName().getIdentifier().equals("fieldOffset")) {
            return;
        }
        for (Expression argument : n.getArguments())
        {
            if (argument.isClassExpr()) {
                ClassExpr classExpr = argument.asClassExpr();
                String type = classExpr.getTypeAsString();
                classExpr.setType(translateQueueName(type));
            }
        }

    }

    @Override
    public void visit(ConstructorDeclaration n, Void arg) {
        super.visit(n, arg);
        // Update the ctor to match the class name
        String nameAsString = n.getNameAsString();
        if (nameAsString.contains("Queue"))
            n.setName(translateQueueName(nameAsString));
    }

    /**
     * Searches all extended or implemented super classes or interfaces for
     * special classes that differ with the atomics version and replaces them
     * with the appropriate class.
     */
    protected void replaceParentClasses(ClassOrInterfaceDeclaration n) {
        for (ClassOrInterfaceType parent : n.getExtendedTypes()) {
            String parentNameAsString = parent.getNameAsString();
            switch (parentNameAsString) {
                case "AbstractQueue":
                    // ignore the JDK parent
                    break;
                default:
                    // Padded super classes are to be renamed and thus so does the
                    // class we must extend.
                    parent.setName(translateQueueName(parentNameAsString));
            }
        }
    }

    protected String formatMultilineJavadoc(int indent, String... lines) {
        String indentation = "";
        for (int i = 0; i < indent; i++) {
            indentation += INDENT_LEVEL;
        }

        String out = "\n";
        for (String line : lines) {
            out += indentation + " * " + line + "\n";
        }
        out += indentation + " ";
        return out;
    }

    private static <T> T buildGenerator(Class<? extends T> generatorClass, String fileName) throws Exception {
        return generatorClass.getDeclaredConstructor(String.class).newInstance(fileName);
    }
}
