package org.jctools.queues.varhandle;

import static org.jctools.queues.util.GeneratorUtils.formatMultilineJavadoc;
import static org.jctools.queues.util.GeneratorUtils.runJCToolsGenerator;

import com.github.javaparser.ast.Modifier;
import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.comments.JavadocComment;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.expr.ClassExpr;
import com.github.javaparser.ast.expr.MarkerAnnotationExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.StringLiteralExpr;
import com.github.javaparser.ast.nodeTypes.NodeWithType;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.CatchClause;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.ReturnStmt;
import com.github.javaparser.ast.stmt.ThrowStmt;
import com.github.javaparser.ast.stmt.TryStmt;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.ModifierVisitor;
import java.util.ArrayList;
import java.util.List;

/**
 * This generator takes in an JCTools 'ArrayQueue' Java source file and patches {@link
 * sun.misc.Unsafe} accesses into {@link java.lang.invoke.VarHandle}. It outputs a Java source file
 * with these patches.
 *
 * <p>An 'ArrayQueue' is one that is backed by a circular array and use a <code>producerLimit</code>
 * and a <code>consumerLimit</code> field to track the positions of each.
 */
public class JavaParsingVarHandleArrayQueueGenerator extends JavaParsingVarHandleQueueGenerator {

  public static void main(String[] args) throws Exception {
    runJCToolsGenerator(JavaParsingVarHandleArrayQueueGenerator.class, args);
  }

  public JavaParsingVarHandleArrayQueueGenerator(String sourceFileName) {
    super(sourceFileName);
  }

  @Override
  void processSpecialNodeTypes(NodeWithType<?, Type> node, String name)
  {
    // nothing to do
  }

  /** Detects the queue type from the source file name */
  private QueueType detectQueueType() {
    String fileName = sourceFileName.toLowerCase();
    if (fileName.contains("spsc")) {
      return QueueType.SPSC;
    } else if (fileName.contains("mpsc")) {
      return QueueType.MPSC;
    } else if (fileName.contains("spmc")) {
      return QueueType.SPMC;
    } else if (fileName.contains("mpmc")) {
      return QueueType.MPMC;
    }
    return QueueType.UNKNOWN;
  }

  enum QueueType {
    SPSC, // Single Producer Single Consumer
    MPSC, // Multi Producer Single Consumer
    SPMC, // Single Producer Multi Consumer
    MPMC, // Multi Producer Multi Consumer
    UNKNOWN
  }

  @Override
  public void visit(ConstructorDeclaration n, Void arg) {
    super.visit(n, arg);
    String nameAsString = n.getNameAsString();
    // Ignore internal class WeakIterator which we don't need to rename
    if (nameAsString.equals("WeakIterator"))
      return;
    // Update the ctor to match the class name
    n.setName(translateQueueName(n.getNameAsString()));
  }

  @Override
  public void visit(ClassOrInterfaceDeclaration node, Void arg) {
    super.visit(node, arg);

    replaceParentClassesForVarHandle(node);

    String nameAsString = node.getNameAsString();
    // Ignore internal class WeakIterator which we don't need to rename
    if (nameAsString.equals("WeakIterator"))
      return;

    node.setName(translateQueueName(node.getNameAsString()));

    if (isCommentPresent(node, GEN_DIRECTIVE_CLASS_CONTAINS_ORDERED_FIELD_ACCESSORS)) {
      node.setComment(null);
      removeStaticFieldsAndInitialisers(node);
      patchVarHandleAccessorMethods(node);
      // Mark that this file has VarHandle fields so we can add proper imports
      hasVarHandleFields = true;
    }

    for (MethodDeclaration method : node.getMethods()) {
      if (isCommentPresent(method, GEN_DIRECTIVE_METHOD_IGNORE)) {
        method.remove();
      }
    }

    if (!node.getMethodsByName("failFastOffer").isEmpty()) {
      MethodDeclaration deprecatedMethodRedirect = node.addMethod("weakOffer", Keyword.PUBLIC);
      patchMethodAsDeprecatedRedirector(
          deprecatedMethodRedirect,
          "failFastOffer",
          PrimitiveType.intType(),
          new Parameter(classType("E"), "e"));
    }

    // Optimize volatile loads to acquire loads where appropriate
    optimizeVolatileLoadsToAcquire(node);

    node.setJavadocComment(
        formatMultilineJavadoc(
                0,
                "NOTE: This class was automatically generated by " + getClass().getName(),
                "which can found in the jctools-build module. The original source file is "
                    + sourceFileName
                    + ".")
            + node.getJavadocComment().orElse(new JavadocComment("")).getContent());
  }

  String varHandleFieldName(String fieldName) {
    switch (fieldName) {
      case "producerIndex":
        return "VH_PRODUCER_INDEX";
      case "consumerIndex":
        return "VH_CONSUMER_INDEX";
      case "producerLimit":
        return "VH_PRODUCER_LIMIT";
      case "producerIndexCache":
        return "VH_PRODUCER_INDEX_CACHE";
      case "blocked":
        return "VH_BLOCKED";
      default:
        throw new IllegalArgumentException("Unhandled field: " + fieldName);
    }
  }

  /**
   * Given a method declaration node this method will replace it's code and signature with code to
   * redirect all calls to it to the <code>newMethodName</code>. Method signatures of both methods
   * must match exactly.
   */
  @SuppressWarnings("SameParameterValue")
  private void patchMethodAsDeprecatedRedirector(
      MethodDeclaration methodToPatch,
      String toMethodName,
      Type returnType,
      Parameter... parameters) {
    methodToPatch.setType(returnType);
    for (Parameter parameter : parameters) {
      methodToPatch.addParameter(parameter);
    }
    methodToPatch.addAnnotation(new MarkerAnnotationExpr("Deprecated"));

    methodToPatch.setJavadocComment(
        formatMultilineJavadoc(
            1, "@deprecated This was renamed to " + toMethodName + " please migrate"));

    MethodCallExpr methodCall = methodCallExpr("this", toMethodName);
    for (Parameter parameter : parameters) {
      methodCall.addArgument(new NameExpr(parameter.getName()));
    }

    BlockStmt body = new BlockStmt();
    body.addStatement(new ReturnStmt(methodCall));
    methodToPatch.setBody(body);
  }

  /**
   * For each method accessor to a field, add in the calls necessary to VarHandle. Only methods
   * start with so/cas/sv/lv/lp/la followed by the field name are processed.
   *
   * @param n the AST node for the containing class
   */
  private void patchVarHandleAccessorMethods(ClassOrInterfaceDeclaration n) {
    String className = n.getNameAsString();
    List<FieldInfo> varHandleFields = new ArrayList<>();

    for (FieldDeclaration field : n.getFields()) {
      if (field.getModifiers().contains(Modifier.staticModifier())) {
        // Ignore statics
        continue;
      }

      // Check if the field is volatile in the original source
      boolean isFieldVolatile = field.getModifiers().contains(Modifier.volatileModifier());

      boolean usesVarHandle = false;
      for (VariableDeclarator variable : field.getVariables()) {
        String variableName = variable.getNameAsString();
        String methodNameSuffix = capitalise(variableName);
        Type fieldType = variable.getType();

        for (MethodDeclaration method : n.getMethods()) {
          usesVarHandle |= patchVarHandleAccessorMethod(variableName, method, methodNameSuffix, isFieldVolatile);
        }

        if (usesVarHandle) {
          varHandleFields.add(new FieldInfo(variableName, fieldType));
          n.getMembers().add(0, declareVarHandle(className, variableName));
          // Only add laXxx method for long fields (not Thread fields)
          if (PrimitiveType.longType().equals(fieldType)) {
            addAcquireLoadMethod(n, variableName);
          }
        }
      }
    }

    // Add static initializer for all VarHandles
    if (!varHandleFields.isEmpty()) {
      n.getMembers().add(1, createVarHandleStaticInitializerWithTypes(className, varHandleFields));
    }
  }

  /** Helper class to track field information */
  private static class FieldInfo {
    final String name;
    final Type type;

    FieldInfo(String name, Type type) {
      this.name = name;
      this.type = type;
    }
  }

  /** Creates a static initializer block for VarHandle initialization with proper field types */
  private InitializerDeclaration createVarHandleStaticInitializerWithTypes(
      String className, List<FieldInfo> fieldInfos) {
    InitializerDeclaration initializer = new InitializerDeclaration(true, new BlockStmt());
    BlockStmt initBody = initializer.getBody();

    // Create try block
    BlockStmt tryBlock = new BlockStmt();
    MethodCallExpr lookup = new MethodCallExpr(new NameExpr("MethodHandles"), "lookup");

    for (FieldInfo fieldInfo : fieldInfos) {
      MethodCallExpr findVarHandle = new MethodCallExpr(lookup, "findVarHandle");
      findVarHandle.addArgument(new ClassExpr(classType(className)));
      findVarHandle.addArgument(new StringLiteralExpr(fieldInfo.name));

      // Determine the field class type
      String fieldClassType = getFieldClassType(fieldInfo.type);
      findVarHandle.addArgument(new ClassExpr(classType(fieldClassType)));

      AssignExpr assignment =
          new AssignExpr(
              new NameExpr(varHandleFieldName(fieldInfo.name)),
              findVarHandle,
              AssignExpr.Operator.ASSIGN);
      tryBlock.addStatement(new ExpressionStmt(assignment));
    }

    // Create catch clause
    Parameter catchParam = new Parameter(classType("Exception"), "e");
    BlockStmt catchBlock = new BlockStmt();
    catchBlock.addStatement(
        new ThrowStmt(
            new ObjectCreationExpr(
                null,
                classType("ExceptionInInitializerError"),
                new NodeList<>(new NameExpr("e")))));
    CatchClause catchClause = new CatchClause(catchParam, catchBlock);

    // Create try-catch statement
    TryStmt tryStmt = new TryStmt(tryBlock, new NodeList<>(catchClause), null);
    initBody.addStatement(tryStmt);

    return initializer;
  }

  /** Adds a laXxx method for acquire-load semantics */
  private void addAcquireLoadMethod(ClassOrInterfaceDeclaration classNode, String variableName) {
    String methodName = "la" + capitalise(variableName);

    // Only add if it doesn't already exist
    if (!classNode.getMethodsByName(methodName).isEmpty()) {
      return;
    }

    MethodDeclaration laMethod = classNode.addMethod(methodName, Keyword.FINAL);
    laMethod.setType(PrimitiveType.longType());

    String varHandleFieldName = varHandleFieldName(variableName);
    laMethod.setBody(varHandleGetAcquire(varHandleFieldName, PrimitiveType.longType()));
  }

  /**
   * Optimizes volatile loads to acquire loads where appropriate based on queue type. The
   * optimization is based on acquire-release semantics: - When reading an index written by
   * setRelease, we can use getAcquire instead of getVolatile - This is more efficient as it uses
   * weaker memory ordering
   */
  private void optimizeVolatileLoadsToAcquire(ClassOrInterfaceDeclaration node) {
    QueueType queueType = detectQueueType();
    if (queueType == QueueType.UNKNOWN) {
      return; // Don't optimize if we can't determine the queue type
    }

    // Visit all methods and replace lv calls with la calls where appropriate
    for (MethodDeclaration method : node.getMethods()) {
      method.accept(
          new ModifierVisitor<Void>() {
            @Override
            public MethodCallExpr visit(MethodCallExpr methodCall, Void arg) {
              super.visit(methodCall, arg);

              final String methodName = methodCall.getNameAsString();

              // Optimize lvProducerIndex() to laProducerIndex()
              if ("lvProducerIndex".equals(methodName)) {
                methodCall.setName("laProducerIndex");

              }
              // Optimize lvConsumerIndex() to laConsumerIndex()
              else if ("lvConsumerIndex".equals(methodName)) {
                methodCall.setName("laConsumerIndex");
              }

              // Optimize lvProducerLimit() to laProducerLimit() (for MPSC)
              else if ("lvProducerLimit".equals(methodName) && queueType == QueueType.MPSC) {
                methodCall.setName("laProducerLimit");
              }

              return methodCall;
            }
          },
          null);
    }
  }
}
