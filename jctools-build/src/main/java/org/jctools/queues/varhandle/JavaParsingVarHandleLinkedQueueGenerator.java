package org.jctools.queues.varhandle;

import com.github.javaparser.ast.Modifier;
import com.github.javaparser.ast.Modifier.Keyword;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.*;
import com.github.javaparser.ast.comments.JavadocComment;
import com.github.javaparser.ast.expr.*;
import com.github.javaparser.ast.nodeTypes.NodeWithType;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.CatchClause;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.ReturnStmt;
import com.github.javaparser.ast.stmt.ThrowStmt;
import com.github.javaparser.ast.stmt.TryStmt;
import com.github.javaparser.ast.type.ArrayType;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.PrimitiveType;
import com.github.javaparser.ast.type.Type;

import java.util.ArrayList;
import java.util.List;

import static org.jctools.queues.util.GeneratorUtils.formatMultilineJavadoc;
import static org.jctools.queues.util.GeneratorUtils.runJCToolsGenerator;

/**
 * This generator takes in an JCTools 'LinkedQueue' Java source file and patches {@link sun.misc.Unsafe} accesses into
 * {@link java.lang.invoke.VarHandle}. It outputs a Java source file with these patches.
 * <p>
 * A 'LinkedQueue' is one that is backed by a linked list and uses a <code>producerNode</code> and a
 * <code>consumerNode</code> field to track the positions of each.
 */
public class JavaParsingVarHandleLinkedQueueGenerator extends JavaParsingVarHandleQueueGenerator {

    private final String mpscLinkedQueueName;

    public static void main(String[] args) throws Exception {
        runJCToolsGenerator(JavaParsingVarHandleLinkedQueueGenerator.class, args);
    }

    public JavaParsingVarHandleLinkedQueueGenerator(String sourceFileName) {
        super(sourceFileName);
        this.mpscLinkedQueueName = varHandleQueueName();
    }

    @Override
    public void visit(ConstructorDeclaration n, Void arg) {
        super.visit(n, arg);
        // Update the ctor to match the class name
        String nameAsString = n.getNameAsString();
        // Ignore internal class WeakIterator which we don't need to rename
        if (nameAsString.equals("WeakIterator"))
            return;
        n.setName(translateQueueName(nameAsString));
        if (mpscLinkedQueueName.equals(nameAsString)) {
            // Special case for MPSC because the Unsafe variant has a static factory method and a protected constructor.
            n.setModifier(Keyword.PROTECTED, false);
            n.setModifier(Keyword.PUBLIC, true);
        }
    }

    private String varHandleQueueName() {
        return "MpscLinked" + queueClassNamePrefix() + "Queue";
    }

    @Override
    public void visit(ClassOrInterfaceDeclaration node, Void arg) {
        super.visit(node, arg);

        replaceParentClassesForVarHandle(node);

        String nameAsString = node.getNameAsString();
        if (nameAsString.contains("Queue"))
            node.setName(translateQueueName(nameAsString));
        if (mpscLinkedQueueName.equals(nameAsString)) {
            /*
             * Special case for MPSC
             */
            node.removeModifier(Keyword.ABSTRACT);
        }

        if (isCommentPresent(node, GEN_DIRECTIVE_CLASS_CONTAINS_ORDERED_FIELD_ACCESSORS)) {
            node.setComment(null);
            removeStaticFieldsAndInitialisers(node);
            patchVarHandleAccessorMethods(node);
        }

        for (MethodDeclaration method : node.getMethods()) {
            if (isCommentPresent(method, GEN_DIRECTIVE_METHOD_IGNORE)) {
                method.remove();
            }
        }

        node.setJavadocComment(formatMultilineJavadoc(0,
                "NOTE: This class was automatically generated by "
                        + getClass().getName(),
                "which can found in the jctools-build module. The original source file is " + sourceFileName + ".")
                + node.getJavadocComment().orElse(new JavadocComment("")).getContent());
    }

    @Override
    public void visit(CastExpr n, Void arg) {
        super.visit(n, arg);

        if (isRefArray(n.getType(), "E")) {
            n.setType(varHandleRefArrayType((ArrayType) n.getType()));
        }
    }

    @Override
    public void visit(MethodDeclaration n, Void arg) {
        super.visit(n, arg);
        // Replace the return type of a method with altered types
        processSpecialNodeTypes(n, n.getNameAsString());
    }

    @Override
    public void visit(ObjectCreationExpr n, Void arg) {
        super.visit(n, arg);
        Type type = n.getType();
        if (isRefType(type, "LinkedQueueNode")) {
            n.setType(simpleParametricType("LinkedQueueVarHandleNode", "E"));
        }
    }

    String varHandleFieldName(String fieldName) {
        switch (fieldName) {
        case "producerNode":
            return "VH_PRODUCER_NODE";
        case "consumerNode":
            return "VH_CONSUMER_NODE";
        case "consumerIndex":
            return "VH_CONSUMER_INDEX";
        case "producerIndex":
            return "VH_PRODUCER_INDEX";
        case "producerLimit":
            return "VH_PRODUCER_LIMIT";
        default:
            throw new IllegalArgumentException("Unhandled field: " + fieldName);
        }
    }

    /**
     * Given a variable declaration of some sort, check its name and type and
     * if it looks like any of the key type changes between unsafe and VarHandle
     * queues, perform the conversion to change its type.
     */
    void processSpecialNodeTypes(NodeWithType<?, Type> node, String name) {
        Type type = node.getType();
        if (node instanceof MethodDeclaration && ("newBufferAndOffset".equals(name) || "nextArrayOffset".equals(name))) {
            node.setType(PrimitiveType.intType());
        } else if (PrimitiveType.longType().equals(type)) {
            switch(name) {
            case "offset":
            case "offsetInNew":
            case "offsetInOld":
            case "lookAheadElementOffset":
                node.setType(PrimitiveType.intType());
            }
        } else if (isRefType(type, "LinkedQueueNode")) {
            node.setType(simpleParametricType("LinkedQueueVarHandleNode", "E"));
        } else if (isRefArray(type, "E")) {
            node.setType(varHandleRefArrayType((ArrayType) type));
        }
    }

    /**
     * For each method accessor to a field, add in the calls necessary to
     * VarHandle. Only methods start with so/cas/sv/lv/lp/la/xchg followed by
     * the field name are processed. Clearly <code>lv</code>, <code>lp</code> and
     * <code>sv</code> are simple field accesses with only <code>so</code>,
     * <code>cas</code> and <code>xchg</code> using the VarHandle.
     *
     * @param n the AST node for the containing class
     */
    private void patchVarHandleAccessorMethods(ClassOrInterfaceDeclaration n) {
        String className = n.getNameAsString();
        List<FieldInfo> varHandleFields = new ArrayList<>();

        for (FieldDeclaration field : n.getFields()) {
            if (field.getModifiers().contains(Modifier.staticModifier())) {
                // Ignore statics
                continue;
            }

            boolean usesVarHandle = false;
            for (VariableDeclarator variable : field.getVariables()) {
                String variableName = variable.getNameAsString();
                String methodNameSuffix = capitalise(variableName);
                Type fieldType = variable.getType();

                for (MethodDeclaration method : n.getMethods()) {
                    usesVarHandle |= patchVarHandleAccessorMethod(variableName, method, methodNameSuffix);
                }

                if ("producerNode".equals(variableName)) {
                    usesVarHandle = true;
                    String varHandleFieldName = varHandleFieldName(variableName);

                    MethodDeclaration method = n.addMethod("xchgProducerNode", Keyword.PROTECTED, Keyword.FINAL);
                    method.setType(simpleParametricType("LinkedQueueVarHandleNode", "E"));
                    method.addParameter(simpleParametricType("LinkedQueueVarHandleNode", "E"), "newValue");
                    method.setBody(varHandleGetAndSet(varHandleFieldName, "newValue", method.getType()));
                }

                if (usesVarHandle) {
                    varHandleFields.add(new FieldInfo(variableName, fieldType));
                    n.getMembers().add(0, declareVarHandle(className, variableName));
                    // Only add laXxx method for long fields
                    if (PrimitiveType.longType().equals(fieldType)) {
                        addAcquireLoadMethod(n, variableName);
                    }
                }
            }

            if (usesVarHandle) {
                field.addModifier(Keyword.VOLATILE);
            }
        }

        // Add static initializer for all VarHandles
        if (!varHandleFields.isEmpty()) {
            n.getMembers().add(1, createVarHandleStaticInitializerWithTypes(className, varHandleFields));
        }
    }

    /**
     * Helper class to track field information
     */
    private static class FieldInfo {
        final String name;
        final Type type;

        FieldInfo(String name, Type type) {
            this.name = name;
            this.type = type;
        }
    }

    /**
     * Creates a static initializer block for VarHandle initialization with proper field types
     */
    private InitializerDeclaration createVarHandleStaticInitializerWithTypes(String className, List<FieldInfo> fieldInfos) {
        InitializerDeclaration initializer = new InitializerDeclaration(true, new BlockStmt());
        BlockStmt initBody = initializer.getBody();

        // Create try block
        BlockStmt tryBlock = new BlockStmt();
        MethodCallExpr lookup = new MethodCallExpr(new NameExpr("MethodHandles"), "lookup");

        for (FieldInfo fieldInfo : fieldInfos) {
            MethodCallExpr findVarHandle = new MethodCallExpr(lookup, "findVarHandle");
            findVarHandle.addArgument(new ClassExpr(classType(className)));
            findVarHandle.addArgument(new StringLiteralExpr(fieldInfo.name));

            // Determine the field class type
            String fieldClassType;
            if (isRefType(fieldInfo.type, "LinkedQueueNode") || isRefType(fieldInfo.type, "LinkedQueueVarHandleNode")) {
                fieldClassType = "LinkedQueueVarHandleNode";
            } else {
                fieldClassType = getFieldClassType(fieldInfo.type);
            }
            findVarHandle.addArgument(new ClassExpr(classType(fieldClassType)));

            AssignExpr assignment = new AssignExpr(
                new NameExpr(varHandleFieldName(fieldInfo.name)),
                findVarHandle,
                AssignExpr.Operator.ASSIGN
            );
            tryBlock.addStatement(new ExpressionStmt(assignment));
        }

        // Create catch clause
        Parameter catchParam = new Parameter(classType("Exception"), "e");
        BlockStmt catchBlock = new BlockStmt();
        catchBlock.addStatement(
            new ThrowStmt(
                new ObjectCreationExpr(
                    null, classType("ExceptionInInitializerError"), new NodeList<>(new NameExpr("e")))));
        CatchClause catchClause = new CatchClause(catchParam, catchBlock);

        // Create try-catch statement
        TryStmt tryStmt = new TryStmt(tryBlock, new NodeList<>(catchClause), null);
        initBody.addStatement(tryStmt);

        return initializer;
    }

    /**
     * Adds a laXxx method for acquire-load semantics
     */
    private void addAcquireLoadMethod(ClassOrInterfaceDeclaration classNode, String variableName) {
        String methodName = "la" + capitalise(variableName);

        // Only add if it doesn't already exist
        if (!classNode.getMethodsByName(methodName).isEmpty()) {
            return;
        }

        MethodDeclaration laMethod = classNode.addMethod(methodName, Keyword.FINAL);
        laMethod.setType(PrimitiveType.longType());

        String varHandleFieldName = varHandleFieldName(variableName);
        laMethod.setBody(varHandleGetAcquire(varHandleFieldName, PrimitiveType.longType()));
    }

    /**
     * Generates something like
     * <code>return (LinkedQueueVarHandleNode<E>) VH_PRODUCER_NODE.getAndSet(this, newValue)</code>
     */
    private BlockStmt varHandleGetAndSet(String varHandleFieldName, String newValueName, Type returnType) {
        BlockStmt body = new BlockStmt();
        CastExpr castExpr = new CastExpr(
                returnType,
                methodCallExpr(varHandleFieldName, "getAndSet", new ThisExpr(), new NameExpr(newValueName)));
        body.addStatement(new ReturnStmt(castExpr));
        return body;
    }

    private ArrayType varHandleRefArrayType(ArrayType in) {
        // VarHandle version uses E[] directly, not a wrapper
        return in;
    }

    private ClassOrInterfaceType simpleParametricType(String typeName, String... typeParams) {
        ClassOrInterfaceType type = new ClassOrInterfaceType(null, typeName);
        if (typeParams.length > 0) {
            NodeList<Type> typeArguments = new NodeList<>();
            for (String typeParam : typeParams) {
                typeArguments.add(classType(typeParam));
            }
            type.setTypeArguments(typeArguments);
        }
        return type;
    }
}
