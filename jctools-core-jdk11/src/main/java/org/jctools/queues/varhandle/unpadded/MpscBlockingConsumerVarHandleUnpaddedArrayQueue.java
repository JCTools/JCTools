/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jctools.queues.varhandle.unpadded;

import java.util.AbstractQueue;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;
import org.jctools.queues.IndexedQueueSizeUtil.IndexedQueue;
import org.jctools.util.Pow2;
import org.jctools.util.RangeUtil;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import org.jctools.queues.*;
import static org.jctools.queues.varhandle.VarHandleQueueUtil.*;
import org.jctools.queues.varhandle.VarHandleReferenceArrayQueue;
import org.jctools.queues.varhandle.SequencedVarHandleReferenceArrayQueue;

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
@SuppressWarnings("unused")
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad1<E> extends AbstractQueue<E> implements IndexedQueue {
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueueColdProducerFields<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad1<E> {

    private static final VarHandle VH_PRODUCER_LIMIT;

    static {
        try {
            VH_PRODUCER_LIMIT = MethodHandles.lookup().findVarHandle(MpscBlockingConsumerVarHandleUnpaddedArrayQueueColdProducerFields.class, "producerLimit", long.class);
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    private volatile long producerLimit;

    protected final int producerMask;

    protected final E[] producerBuffer;

    MpscBlockingConsumerVarHandleUnpaddedArrayQueueColdProducerFields(int producerMask, E[] producerBuffer) {
        this.producerMask = producerMask;
        this.producerBuffer = producerBuffer;
    }

    final long lvProducerLimit() {
        return (long) VH_PRODUCER_LIMIT.getVolatile(this);
    }

    final boolean casProducerLimit(long expect, long newValue) {
        return VH_PRODUCER_LIMIT.compareAndSet(this, expect, newValue);
    }

    final void soProducerLimit(long newValue) {
        VH_PRODUCER_LIMIT.setRelease(this, newValue);
    }

    final long laProducerLimit() {
        return (long) VH_PRODUCER_LIMIT.getAcquire(this);
    }
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
@SuppressWarnings("unused")
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad2<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueueColdProducerFields<E> {

    MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad2(int mask, E[] buffer) {
        super(mask, buffer);
    }
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueueProducerFields<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad2<E> {

    private static final VarHandle VH_PRODUCER_INDEX;

    static {
        try {
            VH_PRODUCER_INDEX = MethodHandles.lookup().findVarHandle(MpscBlockingConsumerVarHandleUnpaddedArrayQueueProducerFields.class, "producerIndex", long.class);
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    private volatile long producerIndex;

    MpscBlockingConsumerVarHandleUnpaddedArrayQueueProducerFields(int mask, E[] buffer) {
        super(mask, buffer);
    }

    @Override
    public final long lvProducerIndex() {
        return (long) VH_PRODUCER_INDEX.getVolatile(this);
    }

    final void soProducerIndex(long newValue) {
        VH_PRODUCER_INDEX.setRelease(this, newValue);
    }

    final boolean casProducerIndex(long expect, long newValue) {
        return VH_PRODUCER_INDEX.compareAndSet(this, expect, newValue);
    }

    final long laProducerIndex() {
        return (long) VH_PRODUCER_INDEX.getAcquire(this);
    }
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
@SuppressWarnings("unused")
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad3<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueueProducerFields<E> {

    MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad3(int mask, E[] buffer) {
        super(mask, buffer);
    }
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 */
abstract class MpscBlockingConsumerVarHandleUnpaddedArrayQueueConsumerFields<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueuePad3<E> {

    private static final VarHandle VH_BLOCKED;

    static {
        try {
            VH_CONSUMER_INDEX = MethodHandles.lookup().findVarHandle(MpscBlockingConsumerVarHandleUnpaddedArrayQueueConsumerFields.class, "consumerIndex", long.class);
            VH_BLOCKED = MethodHandles.lookup().findVarHandle(MpscBlockingConsumerVarHandleUnpaddedArrayQueueConsumerFields.class, "blocked", Thread.class);
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    private static final VarHandle VH_CONSUMER_INDEX;

    private volatile long consumerIndex;

    protected final int consumerMask;

    private volatile Thread blocked;

    protected final E[] consumerBuffer;

    MpscBlockingConsumerVarHandleUnpaddedArrayQueueConsumerFields(int mask, E[] buffer) {
        super(mask, buffer);
        consumerMask = mask;
        consumerBuffer = buffer;
    }

    @Override
    public final long lvConsumerIndex() {
        return (long) VH_CONSUMER_INDEX.getVolatile(this);
    }

    final long lpConsumerIndex() {
        return consumerIndex;
    }

    final void soConsumerIndex(long newValue) {
        VH_CONSUMER_INDEX.setRelease(this, newValue);
    }

    final Thread lvBlocked() {
        return (Thread) VH_BLOCKED.getVolatile(this);
    }

    /**
     * This field should only be written to from the consumer thread. It is set before parking the consumer and nulled
     * when the consumer is unblocked. The value is read by producer thread to unpark the consumer.
     *
     * @param thread the consumer thread which is blocked waiting for the producers
     */
    final void soBlocked(Thread thread) {
        VH_BLOCKED.setRelease(this, thread);
    }

    final long laConsumerIndex() {
        return (long) VH_CONSUMER_INDEX.getAcquire(this);
    }
}

/**
 * NOTE: This class was automatically generated by org.jctools.queues.varhandle.unpadded.JavaParsingVarHandleUnpaddedArrayQueueGenerator
 * which can found in the jctools-build module. The original source file is MpscBlockingConsumerArrayQueue.java.
 *
 * This is a partial implementation of the {@link java.util.concurrent.BlockingQueue} on the consumer side only on top
 * of the mechanics described in {@link BaseMpscLinkedArrayQueue}, but with the reservation bit used for blocking rather
 * than resizing in this instance.
 */
@SuppressWarnings("unused")
public class MpscBlockingConsumerVarHandleUnpaddedArrayQueue<E> extends MpscBlockingConsumerVarHandleUnpaddedArrayQueueConsumerFields<E> implements MessagePassingQueue<E>, QueueProgressIndicators, BlockingQueue<E> {

    public MpscBlockingConsumerVarHandleUnpaddedArrayQueue(final int capacity) {
        // leave lower bit of mask clear
        super((Pow2.roundToPowerOfTwo(capacity) - 1) << 1, (E[]) allocateRefArray(Pow2.roundToPowerOfTwo(capacity)));
        RangeUtil.checkGreaterThanOrEqual(capacity, 1, "capacity");
        // we know it's all empty to start with
        soProducerLimit((Pow2.roundToPowerOfTwo(capacity) - 1) << 1);
    }

    @Override
    public final Iterator<E> iterator() {
        throw new UnsupportedOperationException();
    }

    @Override
    public final int size() {
        return IndexedQueueSizeUtil.size(this, IndexedQueueSizeUtil.IGNORE_PARITY_DIVISOR);
    }

    @Override
    public final boolean isEmpty() {
        // Order matters!
        // Loading consumer before producer allows for producer increments after consumer index is read.
        // This ensures this method is conservative in it's estimate. Note that as this is an MPMC there is
        // nothing we can do to make this an exact method.
        return ((this.laConsumerIndex() / 2) == (this.laProducerIndex() / 2));
    }

    @Override
    public String toString() {
        return this.getClass().getName();
    }

    /**
     * {@link #offer} if {@link #size()} is less than threshold.
     *
     * @param e         the object to offer onto the queue, not null
     * @param threshold the maximum allowable size
     * @return true if the offer is successful, false if queue size exceeds threshold
     * @since 3.0.1
     */
    public boolean offerIfBelowThreshold(final E e, int threshold) {
        if (null == e) {
            throw new NullPointerException();
        }
        final int mask = this.producerMask;
        final long capacity = mask + 2;
        threshold = threshold << 1;
        final E[] buffer = this.producerBuffer;
        long pIndex;
        while (true) {
            pIndex = laProducerIndex();
            // lower bit is indicative of blocked consumer
            if ((pIndex & 1) == 1) {
                if (offerAndWakeup(buffer, mask, pIndex, e)) {
                    return true;
                }
                continue;
            }
            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1), consumer is awake
            final long producerLimit = laProducerLimit();
            // Use producer limit to save a read of the more rapidly mutated consumer index.
            // Assumption: queue is usually empty or near empty
            // available is also << 1
            final long available = producerLimit - pIndex;
            // sizeEstimate <= size
            final long sizeEstimate = capacity - available;
            if (sizeEstimate >= threshold || // producerLimit check allows for threshold >= capacity
            producerLimit <= pIndex) {
                if (!recalculateProducerLimit(pIndex, producerLimit, laConsumerIndex(), capacity, threshold)) {
                    return false;
                }
            }
            // Claim the index
            if (casProducerIndex(pIndex, pIndex + 2)) {
                break;
            }
        }
        final int offset = modifiedCalcCircularRefElementOffset(pIndex, mask);
        // INDEX visible before ELEMENT
        // release element e
        soRefElement(buffer, offset, e);
        return true;
    }

    @Override
    public boolean offer(final E e) {
        if (null == e) {
            throw new NullPointerException();
        }
        final int mask = this.producerMask;
        final E[] buffer = this.producerBuffer;
        long pIndex;
        while (true) {
            pIndex = laProducerIndex();
            // lower bit is indicative of blocked consumer
            if ((pIndex & 1) == 1) {
                if (offerAndWakeup(buffer, mask, pIndex, e))
                    return true;
                continue;
            }
            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1), consumer is awake
            final long producerLimit = laProducerLimit();
            // Use producer limit to save a read of the more rapidly mutated consumer index.
            // Assumption: queue is usually empty or near empty
            if (producerLimit <= pIndex) {
                if (!recalculateProducerLimit(mask, pIndex, producerLimit)) {
                    return false;
                }
            }
            // Claim the index
            if (casProducerIndex(pIndex, pIndex + 2)) {
                break;
            }
        }
        final int offset = modifiedCalcCircularRefElementOffset(pIndex, mask);
        // INDEX visible before ELEMENT
        // release element e
        soRefElement(buffer, offset, e);
        return true;
    }

    @Override
    public void put(E e) throws InterruptedException {
        if (!offer(e))
            throw new UnsupportedOperationException();
    }

    @Override
    public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
        if (offer(e))
            return true;
        throw new UnsupportedOperationException();
    }

    private boolean offerAndWakeup(E[] buffer, int mask, long pIndex, E e) {
        final int offset = modifiedCalcCircularRefElementOffset(pIndex, mask);
        final Thread consumerThread = lvBlocked();
        // We could see a null here through a race with the consumer not yet storing the reference. Just retry.
        if (consumerThread == null) {
            return false;
        }
        // Claim the slot and the responsibility of unparking
        if (!casProducerIndex(pIndex, pIndex + 1)) {
            return false;
        }
        soRefElement(buffer, offset, e);
        LockSupport.unpark(consumerThread);
        return true;
    }

    private boolean recalculateProducerLimit(int mask, long pIndex, long producerLimit) {
        return recalculateProducerLimit(pIndex, producerLimit, laConsumerIndex(), mask + 2, mask + 2);
    }

    private boolean recalculateProducerLimit(long pIndex, long producerLimit, long cIndex, long bufferCapacity, long threshold) {
        // try to update the limit with our new found knowledge on cIndex
        if (cIndex + bufferCapacity > pIndex) {
            casProducerLimit(producerLimit, cIndex + bufferCapacity);
        }
        // full and cannot grow, or hit threshold
        long size = pIndex - cIndex;
        return size < threshold && size < bufferCapacity;
    }

    /**
     * {@inheritDoc}
     * <p>
     * This implementation is correct for single consumer thread use only.
     */
    @Override
    public E take() throws InterruptedException {
        final E[] buffer = consumerBuffer;
        final int mask = consumerMask;
        final long cIndex = lpConsumerIndex();
        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);
        E e = lvRefElement(buffer, offset);
        if (e == null) {
            return parkUntilNext(buffer, cIndex, offset, Long.MAX_VALUE);
        }
        // release element null
        soRefElement(buffer, offset, null);
        // release cIndex
        soConsumerIndex(cIndex + 2);
        return e;
    }

    /**
     * {@inheritDoc}
     * <p>
     * This implementation is correct for single consumer thread use only.
     */
    @Override
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        final E[] buffer = consumerBuffer;
        final int mask = consumerMask;
        final long cIndex = lpConsumerIndex();
        final int offset = modifiedCalcCircularRefElementOffset(cIndex, mask);
        E e = lvRefElement(buffer, offset);
        if (e == null) {
            long timeoutNs = unit.toNanos(timeout);
            if (timeoutNs <= 0) {
                return null;
            }
            return parkUntilNext(buffer, cIndex, offset, timeoutNs);
        }
        // release element null
        soRefElement(buffer, offset, null);
        // release cIndex
        soConsumerIndex(cIndex + 2);
        return e;
    }

    private E parkUntilNext(E[] buffer, long cIndex, int offset, long timeoutNs) throws InterruptedException {
        E e;
        final long pIndex = laProducerIndex();
        if (// queue is empty
        cIndex == pIndex && // we announce ourselves as parked by setting parity
        casProducerIndex(pIndex, pIndex + 1)) {
            // producers only try a wakeup when both the index and the blocked thread are visible, otherwise they spin
            soBlocked(Thread.currentThread());
            // ignore deadline when it's forever
            final long deadlineNs = timeoutNs == Long.MAX_VALUE ? 0 : System.nanoTime() + timeoutNs;
            try {
                while (true) {
                    LockSupport.parkNanos(this, timeoutNs);
                    if (Thread.interrupted()) {
                        casProducerIndex(pIndex + 1, pIndex);
                        throw new InterruptedException();
                    }
                    if ((laProducerIndex() & 1) == 0) {
                        break;
                    }
                    // ignore deadline when it's forever
                    timeoutNs = timeoutNs == Long.MAX_VALUE ? Long.MAX_VALUE : deadlineNs - System.nanoTime();
                    if (timeoutNs <= 0) {
                        if (casProducerIndex(pIndex + 1, pIndex)) {
                            // ran out of time and the producer has not moved the index
                            return null;
                        }
                        // just in the nick of time
                        break;
                    }
                }
            } finally {
                soBlocked(null);
            }
        }
        // producer index is visible before element, so if we wake up between the index moving and the element
        // store we could see a null.
        e = spinWaitForElement(buffer, offset);
        // release element null
        soRefElement(buffer, offset, null);
        // release cIndex
        soConsumerIndex(cIndex + 2);
        return e;
    }

    @Override
    public int remainingCapacity() {
        return capacity() - size();
    }

    @Override
    public int drainTo(Collection<? super E> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int drainTo(Collection<? super E> c, int maxElements) {
        throw new UnsupportedOperationException();
    }

    /**
     * {@inheritDoc}
     * <p>
     * This implementation is correct for single consumer thread use only.
     */
    @Override
    public E poll() {
        final E[] buffer = consumerBuffer;
        final int mask = consumerMask;
        final long index = lpConsumerIndex();
        final int offset = modifiedCalcCircularRefElementOffset(index, mask);
        E e = lvRefElement(buffer, offset);
        if (e == null) {
            // consumer can't see the odd producer index
            if (index != laProducerIndex()) {
                // poll() == null iff queue is empty, null element is not strong enough indicator, so we must
                // check the producer index. If the queue is indeed not empty we spin until element is
                // visible.
                e = spinWaitForElement(buffer, offset);
            } else {
                return null;
            }
        }
        // release element null
        soRefElement(buffer, offset, null);
        // release cIndex
        soConsumerIndex(index + 2);
        return e;
    }

    private static <E> E spinWaitForElement(E[] buffer, int offset) {
        E e;
        do {
            e = lvRefElement(buffer, offset);
        } while (e == null);
        return e;
    }

    /**
     * {@inheritDoc}
     * <p>
     * This implementation is correct for single consumer thread use only.
     */
    @Override
    public E peek() {
        final E[] buffer = consumerBuffer;
        final int mask = consumerMask;
        final long index = lpConsumerIndex();
        final int offset = modifiedCalcCircularRefElementOffset(index, mask);
        E e = lvRefElement(buffer, offset);
        if (e == null && index != laProducerIndex()) {
            // peek() == null iff queue is empty, null element is not strong enough indicator, so we must
            // check the producer index. If the queue is indeed not empty we spin until element is visible.
            e = spinWaitForElement(buffer, offset);
        }
        return e;
    }

    @Override
    public long currentProducerIndex() {
        return laProducerIndex() / 2;
    }

    @Override
    public long currentConsumerIndex() {
        return laConsumerIndex() / 2;
    }

    @Override
    public int capacity() {
        return (int) ((consumerMask + 2) >> 1);
    }

    @Override
    public boolean relaxedOffer(E e) {
        return offer(e);
    }

    @Override
    public E relaxedPoll() {
        final E[] buffer = consumerBuffer;
        final long index = lpConsumerIndex();
        final int mask = consumerMask;
        final int offset = modifiedCalcCircularRefElementOffset(index, mask);
        E e = lvRefElement(buffer, offset);
        if (e == null) {
            return null;
        }
        soRefElement(buffer, offset, null);
        soConsumerIndex(index + 2);
        return e;
    }

    @Override
    public E relaxedPeek() {
        final E[] buffer = consumerBuffer;
        final long index = lpConsumerIndex();
        final int mask = consumerMask;
        final int offset = modifiedCalcCircularRefElementOffset(index, mask);
        return lvRefElement(buffer, offset);
    }

    @Override
    public int fill(Supplier<E> s, int limit) {
        if (null == s)
            throw new IllegalArgumentException("supplier is null");
        if (limit < 0)
            throw new IllegalArgumentException("limit is negative:" + limit);
        if (limit == 0)
            return 0;
        final int mask = this.producerMask;
        long pIndex;
        int claimedSlots;
        Thread blockedConsumer = null;
        long batchLimit = 0;
        final long shiftedBatchSize = 2L * limit;
        while (true) {
            pIndex = laProducerIndex();
            long producerLimit = laProducerLimit();
            // lower bit is indicative of blocked consumer
            if ((pIndex & 1) == 1) {
                // observe the blocked thread for the pIndex
                blockedConsumer = lvBlocked();
                if (blockedConsumer == null)
                    // racing, retry
                    continue;
                if (!casProducerIndex(pIndex, pIndex + 1)) {
                    blockedConsumer = null;
                    continue;
                }
                // We have observed the blocked thread for the pIndex(lv index, lv thread, cas index).
                // We've claimed pIndex, now we need to wake up consumer and set the element
                batchLimit = pIndex + 1;
                pIndex = pIndex - 1;
                break;
            }
            // pIndex is even (lower bit is 0) -> actual index is (pIndex >> 1), consumer is awake
            // we want 'limit' slots, but will settle for whatever is visible to 'producerLimit'
            // -> producerLimit >= batchLimit
            batchLimit = Math.min(producerLimit, pIndex + shiftedBatchSize);
            // Use producer limit to save a read of the more rapidly mutated consumer index.
            // Assumption: queue is usually empty or near empty
            if (pIndex >= producerLimit) {
                if (!recalculateProducerLimit(mask, pIndex, producerLimit)) {
                    return 0;
                }
                batchLimit = Math.min(laProducerLimit(), pIndex + shiftedBatchSize);
            }
            // Claim the index
            if (casProducerIndex(pIndex, batchLimit)) {
                break;
            }
        }
        claimedSlots = (int) ((batchLimit - pIndex) / 2);
        final E[] buffer = this.producerBuffer;
        // first element offset might be a wakeup, so peeled from loop
        for (int i = 0; i < claimedSlots; i++) {
            int offset = modifiedCalcCircularRefElementOffset(pIndex + 2L * i, mask);
            soRefElement(buffer, offset, s.get());
        }
        if (blockedConsumer != null) {
            // no point unblocking an unrelated blocked thread, things have obviously moved on
            if (lvBlocked() == blockedConsumer) {
                LockSupport.unpark(blockedConsumer);
            }
        }
        return claimedSlots;
    }

    /**
     * Remove up to <i>limit</i> elements from the queue and hand to consume, waiting up to the specified wait time if
     * necessary for an element to become available.
     * <p>
     * There's no strong commitment to the queue being empty at the end of it.
     * This implementation is correct for single consumer thread use only.
     * <p>
     * <b>WARNING</b>: Explicit assumptions are made with regards to {@link Consumer#accept} make sure you have read
     * and understood these before using this method.
     *
     * @return the number of polled elements
     * @throws InterruptedException if interrupted while waiting
     * @throws IllegalArgumentException c is {@code null}
     * @throws IllegalArgumentException if limit is negative
     */
    public int drain(Consumer<E> c, final int limit, long timeout, TimeUnit unit) throws InterruptedException {
        if (limit == 0) {
            return 0;
        }
        final int drained = drain(c, limit);
        if (drained != 0) {
            return drained;
        }
        final E e = poll(timeout, unit);
        if (e == null)
            return 0;
        c.accept(e);
        return 1 + drain(c, limit - 1);
    }

    @Override
    public int fill(Supplier<E> s) {
        return MessagePassingQueueUtil.fillBounded(this, s);
    }

    @Override
    public void fill(Supplier<E> s, WaitStrategy wait, ExitCondition exit) {
        MessagePassingQueueUtil.fill(this, s, wait, exit);
    }

    @Override
    public int drain(Consumer<E> c) {
        return drain(c, capacity());
    }

    @Override
    public int drain(final Consumer<E> c, final int limit) {
        return MessagePassingQueueUtil.drain(this, c, limit);
    }

    @Override
    public void drain(Consumer<E> c, WaitStrategy w, ExitCondition exit) {
        MessagePassingQueueUtil.drain(this, c, w, exit);
    }
}
